package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"errors"
	"math"
	"time"
	"warimas-be/internal/cart"
	"warimas-be/internal/graph/model"
	"warimas-be/internal/logger"
	"warimas-be/internal/utils"

	"go.uber.org/zap"
)

// Add to Cart
func (r *mutationResolver) AddToCart(ctx context.Context, input model.AddToCartInput) (*model.AddToCartResponse, error) {
	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("field", "addToCart"),
		zap.String("variant_id", input.VariantID),
		zap.Int32("quantity", input.Quantity),
	)

	start := time.Now()
	log.Info("resolver started")

	respondFail := func(msg string) (*model.AddToCartResponse, error) {
		return &model.AddToCartResponse{
			Success: false,
			Message: &msg,
		}, nil
	}

	// 1️⃣ Auth
	userID, ok := utils.GetUserIDFromContext(ctx)
	if !ok {
		log.Warn("unauthorized access")
		return respondFail("unauthorized")
	}

	log = log.With(zap.Uint("user_id", userID))

	// 2️⃣ Validation
	if input.VariantID == "" || input.Quantity <= 0 {
		log.Warn("invalid input")
		return respondFail("invalid product or quantity")
	}

	// 3️⃣ Service
	cartItem, err := r.CartSvc.AddToCart(ctx, cart.AddToCartParams{
		VariantID: input.VariantID,
		Quantity:  uint32(input.Quantity),
	})
	if err != nil {
		log.Error("add to cart failed",
			zap.Error(err),
			zap.Duration("duration", time.Since(start)),
		)
		return respondFail(err.Error())
	}

	// 4️⃣ Success
	log.Info("add to cart success",
		zap.String("cart_item_id", cartItem.ID),
		zap.Duration("duration", time.Since(start)),
	)

	return &model.AddToCartResponse{
		Success: true,
		CartItem: &model.CartItem{
			ID:        cartItem.ID,
			UserID:    int32(cartItem.UserID),
			Quantity:  cartItem.Quantity,
			CreatedAt: cartItem.CreatedAt.Format(time.RFC3339),
			UpdatedAt: cartItem.UpdatedAt.Format(time.RFC3339),
		},
	}, nil
}

// Update cart quantity
func (r *mutationResolver) UpdateCart(ctx context.Context, input model.UpdateCartInput) (*model.Response, error) {
	log := logger.FromCtx(ctx).With(
		zap.String("layer", "graphql.resolver"),
		zap.String("resolver", "UpdateCart"),
		zap.String("variant_id", input.VariantID),
		zap.Int32("quantity", input.Quantity),
	)

	log.Info("update cart request received")

	// ------------------------------------------------------------------
	// Service Call
	// ------------------------------------------------------------------
	err := r.CartSvc.UpdateCartQuantity(ctx, cart.UpdateToCartParams{
		VariantID: input.VariantID,
		Quantity:  uint32(input.Quantity),
	})

	if err != nil {
		log.Error("failed to update cart",
			zap.Error(err),
		)

		return &model.Response{
			Success: false,
			Message: utils.StrPtr("Failed to update cart"),
		}, nil
	}

	log.Info("cart updated successfully")

	// ------------------------------------------------------------------
	// Response
	// ------------------------------------------------------------------
	return &model.Response{
		Success: true,
		Message: utils.StrPtr("Cart updated"),
	}, nil
}

// Remove item from cart
func (r *mutationResolver) RemoveFromCart(ctx context.Context, variantIds []string) (*model.Response, error) {
	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "RemoveFromCart"),
		zap.Strings("variant_ids", variantIds),
	)

	log.Info("remove from cart request received")

	userID, ok := utils.GetUserIDFromContext(ctx)
	if !ok {
		log.Warn("unauthorized access")
		return &model.Response{
			Success: false,
			Message: utils.StrPtr("Unauthorized"),
		}, nil
	}
	log = log.With(zap.Uint("user_id", userID))

	if len(variantIds) == 0 {
		log.Warn("invalid input: empty variant ID list")
		return &model.Response{
			Success: false,
			Message: utils.StrPtr("Variant IDs are required"),
		}, nil
	}

	// Service expects a slice
	err := r.CartSvc.RemoveFromCart(ctx, variantIds)
	if err != nil {
		if errors.Is(err, cart.ErrCartItemNotFound) {
			return &model.Response{
				Success: false,
				Message: utils.StrPtr("Item not found in cart"),
			}, nil
		}
		log.Error("failed to remove item from cart", zap.Error(err))
		return &model.Response{
			Success: false,
			Message: utils.StrPtr(err.Error()),
		}, nil
	}

	log.Info("item removed from cart successfully")

	return &model.Response{
		Success: true,
		Message: utils.StrPtr("Item removed from cart"),
	}, nil
}

// Get all items in my cart
func (r *queryResolver) MyCart(ctx context.Context, filter *model.CartFilterInput, sort *model.CartSortInput, limit *int32, page *int32) (*model.CartListResponse, error) {
	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "MyCart"),
	)

	log.Info("start MyCart resolver")

	userID, ok := utils.GetUserIDFromContext(ctx)
	if !ok {
		log.Warn("unauthorized access: user id not found in context")
		return nil, errors.New("unauthorized")
	}

	const (
		defaultLimit uint16 = 20
		defaultPage  uint16 = 1
		maxLimit     uint16 = math.MaxUint16
	)

	l := defaultLimit
	p := defaultPage

	if limit != nil {
		if *limit <= 0 {
			log.Warn("invalid limit value", zap.Int32("limit", *limit))
			return nil, errors.New("limit must be greater than 0")
		}
		if *limit > int32(maxLimit) {
			log.Warn("limit exceeds max value", zap.Int32("limit", *limit))
			return nil, errors.New("limit too large")
		}
		l = uint16(*limit)
	}

	if page != nil {
		if *page <= 0 {
			log.Warn("invalid page value", zap.Int32("page", *page))
			return nil, errors.New("page must be greater than 0")
		}
		if *page > int32(math.MaxUint16) {
			log.Warn("page exceeds max value", zap.Int32("page", *page))
			return nil, errors.New("page too large")
		}
		p = uint16(*page)
	}

	log.Debug("resolved cart query params",
		zap.Uint("user_id", userID),
		zap.Uint16("limit", l),
		zap.Uint16("page", p),
		zap.Any("filter", filter),
		zap.Any("sort", sort),
	)

	cartResult, total, err := r.CartSvc.GetCart(
		ctx,
		userID,
		filter,
		sort,
		&l,
		&p,
	)
	if err != nil {
		log.Error("failed to get cart",
			zap.Error(err),
			zap.Uint("user_id", userID),
		)
		// Return generic error to avoid leaking sensitive info
		return nil, errors.New("failed to fetch cart items")
	}

	log.Info("success get cart",
		zap.Uint("user_id", userID),
		zap.Int("item_count", len(cartResult)),
		zap.Int64("total_items", total),
	)

	cartData := cart.MapCartItemToGraphQL(cartResult)

	totalPages := int32((total + int64(l) - 1) / int64(l))

	return &model.CartListResponse{
		Items: cartData,
		PageInfo: &model.PageInfo{
			TotalItems:      int32(total),
			TotalPages:      totalPages,
			Page:            int32(p),
			Limit:           int32(l),
			HasNextPage:     int32(p) < totalPages,
			HasPreviousPage: p > 1,
		},
	}, nil
}

// Get cart item count
func (r *queryResolver) MyCartCount(ctx context.Context) (int32, error) {
	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "MyCartCount"),
	)

	userID, ok := utils.GetUserIDFromContext(ctx)
	if !ok {
		log.Warn("unauthorized access")
		return 0, errors.New("unauthorized")
	}

	count, err := r.CartSvc.GetCartCount(ctx, userID)
	if err != nil {
		return 0, errors.New("failed to get cart count")
	}

	return int32(count), nil
}
