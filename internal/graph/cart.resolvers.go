package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"errors"
	"math"
	"time"
	"warimas-be/internal/cart"
	"warimas-be/internal/graph/model"
	"warimas-be/internal/logger"
	"warimas-be/internal/utils"

	"go.uber.org/zap"
)

// Add to Cart
func (r *mutationResolver) AddToCart(ctx context.Context, input model.AddToCartInput) (*model.AddToCartResponse, error) {
	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("field", "addToCart"),
		zap.String("variant_id", input.VariantID),
		zap.Int32("quantity", input.Quantity),
	)

	start := time.Now()
	log.Info("resolver started")

	respondFail := func(msg string) (*model.AddToCartResponse, error) {
		return &model.AddToCartResponse{
			Success: false,
			Message: &msg,
		}, nil
	}

	// 1️⃣ Auth
	userID, ok := utils.GetUserIDFromContext(ctx)
	if !ok {
		log.Warn("unauthorized access")
		return respondFail("unauthorized")
	}

	log = log.With(zap.Uint("user_id", userID))

	// 2️⃣ Validation
	if input.VariantID == "" || input.Quantity <= 0 {
		log.Warn("invalid input")
		return respondFail("invalid product or quantity")
	}

	// 3️⃣ Service
	cartItem, err := r.CartSvc.AddToCart(ctx, cart.AddToCartParams{
		UserID:    userID,
		VariantID: input.VariantID,
		Quantity:  uint32(input.Quantity),
	})
	if err != nil {
		log.Error("add to cart failed",
			zap.Error(err),
			zap.Duration("duration", time.Since(start)),
		)
		return respondFail(err.Error())
	}

	// 4️⃣ Success
	log.Info("add to cart success",
		zap.String("cart_item_id", cartItem.ID),
		zap.Duration("duration", time.Since(start)),
	)

	return &model.AddToCartResponse{
		Success: true,
		CartItem: &model.CartItem{
			ID:        cartItem.ID,
			UserID:    int32(cartItem.UserID),
			Quantity:  cartItem.Quantity,
			CreatedAt: cartItem.CreatedAt.Format(time.RFC3339),
			UpdatedAt: cartItem.UpdatedAt.Format(time.RFC3339),
		},
	}, nil
}

// Update cart quantity
func (r *mutationResolver) UpdateCart(ctx context.Context, input model.UpdateCartInput) (*model.Response, error) {
	userID, ok := utils.GetUserIDFromContext(ctx)
	if !ok {
		return &model.Response{
			Success: false,
			Message: utils.StrPtr("Unauthorized"),
		}, nil
	}

	err := r.CartSvc.UpdateCartQuantity(ctx, cart.UpdateToCartParams{
		UserID:    uint32(userID),
		VariantID: input.VariantID,
		Quantity:  uint32(input.Quantity),
	})

	if err != nil {
		return &model.Response{
			Success: false,
			Message: utils.StrPtr(err.Error()),
		}, nil
	}

	return &model.Response{
		Success: true,
		Message: utils.StrPtr("Cart updated"),
	}, nil
}

// Remove item from cart
func (r *mutationResolver) RemoveFromCart(ctx context.Context, variantID string) (*model.Response, error) {
	userID, ok := utils.GetUserIDFromContext(ctx)
	if !ok {
		return &model.Response{
			Success: false,
			Message: utils.StrPtr("Unauthorized"),
		}, nil
	}

	err := r.CartSvc.RemoveFromCart(ctx, cart.DeleteFromCartParams{UserID: uint32(userID)})
	if err != nil {
		return &model.Response{
			Success: false,
			Message: utils.StrPtr(err.Error()),
		}, nil
	}
	return &model.Response{
		Success: true,
		Message: utils.StrPtr("Cart updated"),
	}, nil
}

// Get all items in my cart
func (r *queryResolver) MyCart(ctx context.Context, filter *model.CartFilterInput, sort *model.CartSortInput, limit *int32, page *int32) ([]*model.CartItem, error) {
	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "MyCart"),
	)

	log.Info("start MyCart resolver")

	userID, ok := utils.GetUserIDFromContext(ctx)
	if !ok {
		log.Warn("unauthorized access: user id not found in context")
		return nil, errors.New("unauthorized")
	}

	const (
		defaultLimit uint16 = 20
		defaultPage  uint16 = 1
		maxLimit     uint16 = math.MaxUint16
	)

	l := defaultLimit
	p := defaultPage

	if limit != nil {
		if *limit <= 0 {
			log.Warn("invalid limit value", zap.Int32("limit", *limit))
			return nil, errors.New("limit must be greater than 0")
		}
		if *limit > int32(maxLimit) {
			log.Warn("limit exceeds max value", zap.Int32("limit", *limit))
			return nil, errors.New("limit too large")
		}
		l = uint16(*limit)
	}

	if page != nil {
		if *page <= 0 {
			log.Warn("invalid page value", zap.Int32("page", *page))
			return nil, errors.New("page must be greater than 0")
		}
		if *page > int32(math.MaxUint16) {
			log.Warn("page exceeds max value", zap.Int32("page", *page))
			return nil, errors.New("page too large")
		}
		p = uint16(*page)
	}

	log.Debug("resolved cart query params",
		zap.Uint("user_id", userID),
		zap.Uint16("limit", l),
		zap.Uint16("page", p),
		zap.Any("filter", filter),
		zap.Any("sort", sort),
	)

	cartResult, err := r.CartSvc.GetCart(
		ctx,
		userID,
		filter,
		sort,
		&l,
		&p,
	)
	if err != nil {
		log.Error("failed to get cart",
			zap.Error(err),
			zap.Uint("user_id", userID),
		)
		return nil, err
	}

	log.Info("success get cart",
		zap.Uint("user_id", userID),
		zap.Int("item_count", len(cartResult)),
	)

	return cartResult, nil
}
