package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"errors"
	"fmt"
	"warimas-be/internal/graph/model"
	"warimas-be/internal/logger"
	"warimas-be/internal/order"
	"warimas-be/internal/utils"

	"go.uber.org/zap"
)

// CreateOrderFromSession is the resolver for the createOrderFromSession field.
func (r *mutationResolver) CreateOrderFromSession(ctx context.Context, input model.CreateOrderFromSessionInput) (*model.CreateOrderResponse, error) {
	// STRONGLY RECOMMENDED:
	// protect this with ADMIN or INTERNAL auth
	if !utils.IsInternalRequest(ctx) {
		return nil, errors.New("forbidden")
	}

	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "CreateOrderFromSession"),
		zap.String("session_id", input.SessionID),
	)

	orderCreated, err := r.OrderSvc.CreateFromSession(
		ctx,
		input.SessionID,
	)
	if err != nil {
		log.Error("failed to create order from session", zap.Error(err))
		return nil, err
	}

	return &model.CreateOrderResponse{
		Success: true,
		Order:   order.ToGraphQLOrder(orderCreated),
	}, nil
}

// UpdateOrderStatus is the resolver for the updateOrderStatus field.
func (r *mutationResolver) UpdateOrderStatus(ctx context.Context, input model.UpdateOrderStatusInput) (*model.CreateOrderResponse, error) {
	// Admin only â€” you already handle auth via @auth(role: ADMIN)
	orderID, err := utils.ToUint(input.OrderID)
	if err != nil {
		return &model.CreateOrderResponse{
			Success: false,
			Message: utils.StrPtr("Invalid order ID"),
		}, nil
	}

	status := order.OrderStatus(input.Status.String())

	err = r.OrderSvc.UpdateOrderStatus(orderID, status)
	if err != nil {
		return &model.CreateOrderResponse{
			Success: false,
			Message: utils.StrPtr(err.Error()),
		}, nil
	}

	return &model.CreateOrderResponse{
		Success: true,
		Message: utils.StrPtr(fmt.Sprintf("Order updated to %s", status)),
	}, nil
}

// CreateSessionCheckout is the resolver for the createSessionCheckout field.
func (r *mutationResolver) CreateSessionCheckout(
	ctx context.Context,
	input model.CreateSessionCheckoutInput,
) (*model.SessionCheckoutResponse, error) {

	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "CreateSessionCheckout"),
		zap.Int("item_count", len(input.Items)),
	)

	log.Info("create session checkout request received")

	if len(input.Items) == 0 {
		log.Warn("validation failed: items empty")
		return nil, errors.New("items must not be empty")
	}

	session, err := r.OrderSvc.CreateSession(ctx, input)
	if err != nil {
		log.Error(
			"failed to create checkout session",
			zap.Error(err),
		)
		return nil, err
	}

	log.Info(
		"checkout session created",
		zap.String("session_id", session.ID.String()),
		zap.String("status", string(session.Status)),
		zap.Time("expires_at", session.ExpiresAt),
	)

	return &model.SessionCheckoutResponse{
		SessionID: session.ID.String(),
		Status:    model.CheckoutSessionStatus(session.Status),
		ExpiresAt: session.ExpiresAt,
	}, nil
}

// UpdateSessionAddress is the resolver for the updateSessionAddress field.
func (r *mutationResolver) UpdateSessionAddress(ctx context.Context, input model.UpdateSessionAddressInput) (*model.UpdateSessionAddressResponse, error) {
	userID, ok := utils.GetUserIDFromContext(ctx)
	if !ok {
		return nil, errors.New("unauthorized")
	}

	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "UpdateSessionAddress"),
		zap.String("session_id", input.SessionID),
		zap.Uint("user_id", userID),
	)

	err := r.OrderSvc.UpdateSessionAddress(
		ctx,
		input.SessionID,
		userID,
		input.AddressID,
	)
	if err != nil {
		log.Error("failed to update session address", zap.Error(err))
		return nil, err
	}

	return &model.UpdateSessionAddressResponse{
		Success: true,
	}, nil
}

// ConfirmCheckoutSession is the resolver for the confirmCheckoutSession field.
func (r *mutationResolver) ConfirmCheckoutSession(ctx context.Context, input model.ConfirmCheckoutSessionInput) (*model.ConfirmCheckoutSessionResponse, error) {
	userID, ok := utils.GetUserIDFromContext(ctx)
	if !ok {
		return nil, errors.New("unauthorized")
	}

	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "ConfirmCheckoutSession"),
		zap.String("session_id", input.SessionID),
		zap.Uint("user_id", userID),
	)

	session, err := r.OrderSvc.ConfirmSession(
		ctx,
		input.SessionID,
		userID,
	)
	if err != nil {
		log.Error("failed to confirm checkout session", zap.Error(err))
		return nil, err
	}

	msg := "checkout session confirmed"

	return &model.ConfirmCheckoutSessionResponse{
		Success: true,
		Message: &msg,
		Session: order.MapCheckoutSessionToGraphQL(session),
	}, nil
}

// OrderList is the resolver for the orderList field.
func (r *queryResolver) OrderList(ctx context.Context, filter *model.OrderFilterInput, sort *model.OrderSortInput, limit *int32, page *int32) (*model.OrderListResponse, error) {
	orders, err := r.OrderSvc.GetOrders(ctx, filter, sort, limit, page)
	if err != nil {
		return nil, err
	}

	return &model.OrderListResponse{
		Items: orders,
		Total: int32(len(orders)),
	}, nil
}

// OrderDetail is the resolver for the orderDetail field.
func (r *queryResolver) OrderDetail(ctx context.Context, orderID string) (*model.Order, error) {
	userID, ok := utils.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	oid, err := utils.ToUint(orderID)
	if err != nil {
		return nil, err
	}

	orderDetail, err := r.OrderSvc.GetOrderDetail(uint(userID), oid, false)
	if err != nil {
		return nil, err
	}

	return order.ToGraphQLOrder(orderDetail), nil
}

// CheckoutSession is the resolver for the checkoutSession field.
func (r *queryResolver) CheckoutSession(ctx context.Context, id string) (*model.CheckoutSession, error) {
	userID, _ := utils.GetUserIDFromContext(ctx) // guest allowed

	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "CheckoutSession"),
		zap.String("session_id", id),
	)

	session, err := r.OrderSvc.GetSession(
		ctx,
		id,
		&userID,
	)
	if err != nil {
		log.Error("failed to get checkout session", zap.Error(err))
		return nil, err
	}

	return order.MapCheckoutSessionToGraphQL(session), nil
}
