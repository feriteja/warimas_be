package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"errors"
	"fmt"
	"warimas-be/internal/address"
	"warimas-be/internal/graph/model"
	"warimas-be/internal/logger"
	"warimas-be/internal/order"
	"warimas-be/internal/payment"
	"warimas-be/internal/utils"

	"go.uber.org/zap"
)

// CreateOrderFromSession is the resolver for the createOrderFromSession field.
func (r *mutationResolver) CreateOrderFromSession(ctx context.Context, input model.CreateOrderFromSessionInput) (*model.CreateOrderResponse, error) {
	// STRONGLY RECOMMENDED:
	// protect this with ADMIN or INTERNAL auth
	if !utils.IsInternalRequest(ctx) {
		return nil, errors.New("forbidden")
	}

	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "CreateOrderFromSession"),
		zap.String("session_id", input.ExternalID),
	)

	orderCreated, err := r.OrderSvc.CreateFromSession(
		ctx,
		input.ExternalID,
	)
	if err != nil {
		log.Error("failed to create order from session", zap.Error(err))
		return nil, err
	}

	log.Info("order created from session", zap.Int32("order_id", orderCreated.ID))

	return &model.CreateOrderResponse{
		Success: true,
		Order:   order.ToGraphQLOrder(orderCreated, nil),
	}, nil
}

// UpdateOrderStatus is the resolver for the updateOrderStatus field.
func (r *mutationResolver) UpdateOrderStatus(ctx context.Context, input model.UpdateOrderStatusInput) (*model.CreateOrderResponse, error) {
	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "UpdateOrderStatus"),
		zap.String("order_id", input.OrderID),
		zap.String("status", input.Status.String()),
	)

	log.Info("update order status request received")

	// Admin only â€” you already handle auth via @auth(role: ADMIN)
	orderID, err := utils.ToUint(input.OrderID)
	if err != nil {
		log.Warn("invalid order id", zap.Error(err))
		return &model.CreateOrderResponse{
			Success: false,
			Message: utils.StrPtr("Invalid order ID"),
		}, nil
	}

	status := order.OrderStatus(input.Status.String())

	err = r.OrderSvc.UpdateOrderStatus(ctx, orderID, status)
	if err != nil {
		log.Error("failed to update order status", zap.Error(err))
		return &model.CreateOrderResponse{
			Success: false,
			Message: utils.StrPtr(err.Error()),
		}, nil
	}

	log.Info("order status updated successfully")

	return &model.CreateOrderResponse{
		Success: true,
		Message: utils.StrPtr(fmt.Sprintf("Order updated to %s", status)),
	}, nil
}

// CreateCheckoutSession is the resolver for the CreateCheckoutSession field.
func (r *mutationResolver) CreateCheckoutSession(ctx context.Context, input model.CreateCheckoutSessionInput) (*model.CheckoutSessionResponse, error) {
	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "CreateCheckoutSession"),
		zap.Int("item_count", len(input.Items)),
	)

	log.Info("create session checkout request received")

	if len(input.Items) == 0 {
		log.Warn("validation failed: items empty")
		return nil, errors.New("items must not be empty")
	}

	session, err := r.OrderSvc.CreateSession(ctx, input)
	if err != nil {
		log.Error(
			"failed to create checkout session",
			zap.Error(err),
		)
		return nil, err
	}

	log.Info(
		"checkout session created",
		zap.String("session_id", session.ID.String()),
		zap.String("status", string(session.Status)),
		zap.Time("expires_at", session.ExpiresAt),
	)

	return &model.CheckoutSessionResponse{
		ExternalID: session.ExternalID,
		Status:     model.CheckoutSessionStatus(session.Status),
		ExpiresAt:  session.ExpiresAt,
	}, nil
}

// UpdateSessionAddress is the resolver for the updateSessionAddress field.
func (r *mutationResolver) UpdateSessionAddress(ctx context.Context, input model.UpdateSessionAddressInput) (*model.UpdateSessionAddressResponse, error) {
	logFields := []zap.Field{
		zap.String("layer", "resolver"),
		zap.String("method", "UpdateSessionAddress"),
		zap.String("session_id", input.ExternalID),
		zap.String("address_id", input.AddressID),
	}

	if input.GuestID != nil {
		logFields = append(logFields, zap.String("guest_id", *input.GuestID))
	}

	log := logger.FromCtx(ctx).With(logFields...)

	err := r.OrderSvc.UpdateSessionAddress(
		ctx,
		input.ExternalID,
		input.AddressID,
		input.GuestID,
	)
	if err != nil {
		log.Error("failed to update session address", zap.Error(err))
		return nil, err
	}

	log.Info("session address updated successfully")

	return &model.UpdateSessionAddressResponse{
		Success: true,
	}, nil
}

// UpdateSessionPaymentMethod is the resolver for the updateSessionPaymentMethod field.
func (r *mutationResolver) UpdateSessionPaymentMethod(ctx context.Context, input model.UpdateSessionPaymentMethodInput) (*model.UpdateSessionPaymentMethodResponse, error) {
	logFields := []zap.Field{
		zap.String("layer", "resolver"),
		zap.String("method", "UpdateSessionPaymentMethod"),
		zap.String("session_id", input.ExternalID),
		zap.String("payment_method", input.PaymentMethod),
	}

	if input.GuestID != nil {
		logFields = append(logFields, zap.String("guest_id", *input.GuestID))
	}

	log := logger.FromCtx(ctx).With(logFields...)

	err := r.OrderSvc.UpdateSessionPaymentMethod(
		ctx,
		input.ExternalID,
		payment.ChannelCode(input.PaymentMethod),
		input.GuestID,
	)
	if err != nil {
		log.Error("failed to update session payment method", zap.Error(err))
		return nil, err
	}

	log.Info("session payment method updated successfully")

	return &model.UpdateSessionPaymentMethodResponse{
		Success: true,
	}, nil
}

// ConfirmCheckoutSession is the resolver for the confirmCheckoutSession field.
func (r *mutationResolver) ConfirmCheckoutSession(ctx context.Context, input model.ConfirmCheckoutSessionInput) (*model.ConfirmCheckoutSessionResponse, error) {
	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "ConfirmCheckoutSession"),
		zap.String("external_id", input.ExternalID),
	)

	orderExternalID, err := r.OrderSvc.ConfirmSession(
		ctx,
		input.ExternalID,
	)
	if err != nil {
		log.Error("failed to confirm checkout session", zap.Error(err))
		return nil, err
	}

	msg := "checkout session confirmed"

	return &model.ConfirmCheckoutSessionResponse{
		Success:         true,
		Message:         &msg,
		OrderExternalID: *orderExternalID,
	}, nil
}

// OrderList is the resolver for the orderList field.
func (r *queryResolver) OrderList(ctx context.Context, filter *model.OrderFilterInput, sort *model.OrderSortInput, pagination *model.PaginationInput) (*model.OrderListResponse, error) {
	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "OrderList"),
	)

	// Defaults
	limit := int32(20)
	page := int32(1)

	if pagination != nil {
		if pagination.Limit > 0 {
			limit = pagination.Limit
		}
		if pagination.Page > 0 {
			page = pagination.Page
		}
	}

	log.Info("order list request started",
		zap.Int32("limit", limit),
		zap.Int32("page", page),
	)

	// Map filter
	filterOrder := &order.OrderFilterInput{}
	if filter != nil {
		filterOrder.Search = filter.Search
		filterOrder.DateFrom = filter.DateFrom
		filterOrder.DateTo = filter.DateTo

		if filter.Status != nil {
			status := order.OrderStatus(*filter.Status)
			filterOrder.Status = &status
		}
	}

	// Map sort
	sortOrder := &order.OrderSortInput{
		Field:     order.OrderSortFieldCreatedAt,
		Direction: order.SortDirectionDesc,
	}

	if sort != nil {
		sortOrder.Field = order.OrderSortField(sort.Field)
		sortOrder.Direction = order.SortDirection(sort.Direction)
	}

	// Fetch data
	orders, total, addressMap, err := r.OrderSvc.GetOrders(
		ctx,
		filterOrder,
		sortOrder,
		limit,
		page,
	)
	if err != nil {
		log.Error("order list request failed", zap.Error(err))
		return nil, err
	}

	log.Info("order list request success",
		zap.Int("items_count", len(orders)),
		zap.Int64("total_items", total),
	)

	// Map orders to GraphQL
	items := make([]*model.Order, 0, len(orders))

	for _, o := range orders {
		var addr *address.Address

		if list, ok := addressMap[o.AddressID]; ok && len(list) > 0 {
			addr = &list[0] // usually 1 address per order
		}

		items = append(items, order.ToGraphQLOrder(o, addr))
	}

	// Page info
	totalPages := int32((total + int64(limit) - 1) / int64(limit))

	pageInfo := &model.PageInfoOrder{
		TotalItems:      int32(total),
		TotalPages:      totalPages,
		Page:            page,
		Limit:           limit,
		HasNextPage:     page < totalPages,
		HasPreviousPage: page > 1,
	}

	return &model.OrderListResponse{
		Items:    items,
		PageInfo: pageInfo,
	}, nil
}

// OrderDetail is the resolver for the orderDetail field.
func (r *queryResolver) OrderDetail(ctx context.Context, orderID string) (*model.Order, error) {
	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "OrderDetail"),
		zap.String("order_id", orderID),
	)

	log.Info("order detail request received")

	oid, err := utils.ToUint(orderID)
	if err != nil {
		log.Warn("invalid order id", zap.Error(err))
		return nil, err
	}

	orderDetail, address, err := r.OrderSvc.GetOrderDetail(ctx, oid)
	if err != nil {
		log.Error("failed to get order detail", zap.Error(err))
		return nil, err
	}

	log.Info("order detail fetched successfully")

	return order.ToGraphQLOrder(orderDetail, address), nil
}

// OrderDetailByExternalID is the resolver for the orderDetailByExternalId field.
func (r *queryResolver) OrderDetailByExternalID(ctx context.Context, externalID string) (*model.Order, error) {
	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "OrderDetailByExternalID"),
		zap.String("external_id", externalID),
	)

	log.Info("order detail request received")

	orderDetail, address, err := r.OrderSvc.GetOrderDetailByExternalID(ctx, externalID)
	if err != nil {
		log.Error("failed to get order detail", zap.Error(err))
		return nil, err
	}

	log.Info("order detail fetched successfully")

	return order.ToGraphQLOrder(orderDetail, address), nil
}

// CheckoutSession is the resolver for the checkoutSession field.
func (r *queryResolver) CheckoutSession(ctx context.Context, externalID string) (*model.CheckoutSession, error) {
	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "CheckoutSession"),
		zap.String("external_id", externalID),
	)

	session, err := r.OrderSvc.GetSession(
		ctx,
		externalID,
	)
	if err != nil {
		log.Error("failed to get checkout session", zap.Error(err))
		return nil, err
	}

	return order.MapCheckoutSessionToGraphQL(session), nil
}

// PaymentOrderInfo is the resolver for the paymentOrderInfo field.
func (r *queryResolver) PaymentOrderInfo(ctx context.Context, externalID string) (*model.PaymentOrderInfoResponse, error) {
	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "PaymentOrderInfo"),
		zap.String("external_id", externalID),
	)

	paymentInfo, err := r.OrderSvc.GetPaymentOrderInfo(
		ctx,
		externalID,
	)
	if err != nil {
		log.Error("failed to get checkout session", zap.Error(err))
		return nil, err
	}

	paymentInfoMap := &model.PaymentOrderInfoResponse{
		OrderExternalID: paymentInfo.OrderExternalID,
		Status:          model.PaymentStatus(paymentInfo.Status),
		TotalAmount:     int32(paymentInfo.TotalAmount),
		Currency:        paymentInfo.Currency,
		ExpiresAt:       paymentInfo.ExpiresAt,
		ShippingAddress: &model.ShippingAddress{
			Name:         paymentInfo.ShippingAddress.Name,
			ReceiverName: paymentInfo.ShippingAddress.ReceiverName,
			Phone:        paymentInfo.ShippingAddress.Phone,
			Address1:     paymentInfo.ShippingAddress.Address1,
			Address2:     paymentInfo.ShippingAddress.Address2,
			City:         paymentInfo.ShippingAddress.City,
			Province:     paymentInfo.ShippingAddress.Province,
			PostalCode:   paymentInfo.ShippingAddress.PostalCode,
		},
		Payment: &model.PaymentDetail{
			Method:       string(paymentInfo.Payment.Method),
			PaymentCode:  paymentInfo.Payment.PaymentCode,
			ReferenceID:  paymentInfo.Payment.ReferenceID,
			InvoiceURL:   paymentInfo.Payment.InvoiceURL,
			Instructions: paymentInfo.Payment.Instructions,
		}}

	return paymentInfoMap, nil
}
