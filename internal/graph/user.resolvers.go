package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"
	"net/http"
	"time"
	"warimas-be/internal/graph/model"
	"warimas-be/internal/logger"
	"warimas-be/internal/transport"
	"warimas-be/internal/user"
	"warimas-be/internal/utils"

	"go.uber.org/zap"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthResponse, error) {
	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "Register"),
		zap.String("email", input.Email),
	)

	log.Info("register request received")

	token, u, err := r.UserSvc.Register(ctx, input.Email, input.Password)
	if err != nil {
		log.Warn("register failed", zap.Error(err))
		return nil, err
	}

	w := transport.GetResponseWriter(ctx) // <-- your helper
	if w != nil {
		http.SetCookie(w, &http.Cookie{
			Name:     "access_token",
			Value:    token,
			Path:     "/",
			HttpOnly: true,
			Secure:   true, // HTTPS only
			SameSite: http.SameSiteNoneMode,
			MaxAge:   60 * 60 * 24, // 24 hours
		})
	}

	log.Info("user registered successfully",
		zap.String("user_id", fmt.Sprint(u.ID)),
	)

	return &model.AuthResponse{
		Token: &token,
		User: &model.User{
			ID:    fmt.Sprint(u.ID),
			Email: u.Email,
			Role:  model.Role(u.Role),
		},
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthResponse, error) {
	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "Login"),
		zap.String("email", input.Email),
	)

	log.Info("login request received")

	token, u, err := r.UserSvc.Login(ctx, input.Email, input.Password)
	if err != nil {
		log.Warn("login failed",
			zap.Error(err),
		)
		return nil, err
	}

	w := transport.GetResponseWriter(ctx) // <-- your helper
	if w != nil {
		http.SetCookie(w, &http.Cookie{
			Name:     "access_token",
			Value:    token,
			Path:     "/",
			HttpOnly: true,
			Secure:   true, // HTTPS only
			SameSite: http.SameSiteNoneMode,
			MaxAge:   60 * 60 * 24, // 24 hours
		})
	}

	log.Info("login successful",
		zap.String("user_id", fmt.Sprint(u.ID)),
		zap.String("role", string(u.Role)),
	)

	return &model.AuthResponse{
		Token: &token,
		User: &model.User{
			ID:    fmt.Sprint(u.ID),
			Email: u.Email,
			Role:  model.Role(u.Role),
		},
	}, nil
}

// ForgotPassword is the resolver for the forgotPassword field.
func (r *mutationResolver) ForgotPassword(ctx context.Context, input model.ForgotPasswordInput) (*model.ForgotPasswordResponse, error) {
	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "ForgotPassword"),
		zap.String("email", input.Email),
	)

	log.Info("forgot password request received")

	if err := r.UserSvc.ForgotPassword(ctx, input.Email); err != nil {
		log.Error("forgot password failed", zap.Error(err))
		return nil, err
	}

	log.Info("forgot password email sent")

	return &model.ForgotPasswordResponse{
		Success: true,
		Message: utils.StrPtr("If your email is registered, you will receive a password reset link shortly."),
	}, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, input model.ResetPasswordInput) (*model.ResetPasswordResponse, error) {
	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "ResetPassword"),
	)

	log.Info("reset password request received")

	if err := r.UserSvc.ResetPassword(ctx, input.Token, input.NewPassword); err != nil {
		log.Error("reset password failed", zap.Error(err))
		return nil, err
	}

	log.Info("password reset successful")

	return &model.ResetPasswordResponse{
		Success: true,
		Message: utils.StrPtr("Password successfully reset"),
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "Logout"),
	)

	log.Info("logout request received")

	w := transport.GetResponseWriter(ctx)
	if w != nil {
		http.SetCookie(w, &http.Cookie{
			Name:     "access_token",
			Value:    "",
			Path:     "/",
			HttpOnly: true,
			Secure:   true,
			SameSite: http.SameSiteNoneMode,
			MaxAge:   -1,
		})
	}

	log.Info("user logged out")

	return true, nil
}

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, input model.UpdateProfileInput) (*model.Profile, error) {
	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "UpdateProfile"),
	)

	userID, ok := utils.GetUserIDFromContext(ctx)
	if !ok {
		log.Warn("unauthorized update profile attempt")
		return nil, fmt.Errorf("unauthorized")
	}

	log = log.With(zap.Uint("user_id", userID))
	log.Info("update profile request received")

	var dob *time.Time
	if input.DateOfBirth != nil {
		parsed, err := time.Parse("2006-01-02", *input.DateOfBirth)
		if err != nil {
			log.Error("invalid date format", zap.String("date", *input.DateOfBirth), zap.Error(err))
			return nil, fmt.Errorf("invalid date format, expected YYYY-MM-DD")
		}
		dob = &parsed
	}

	params := user.UpdateProfileParams{
		UserID:      userID,
		FullName:    input.FullName,
		Bio:         input.Bio,
		AvatarURL:   input.AvatarURL,
		Phone:       input.Phone,
		DateOfBirth: dob,
	}

	updated, err := r.UserSvc.UpdateProfile(ctx, params)
	if err != nil {
		log.Error("failed to update profile", zap.Error(err))
		return nil, err
	}

	log.Info("profile updated successfully")

	return mapProfileToGraphQL(updated), nil
}

// MyProfile is the resolver for the myProfile field.
func (r *queryResolver) MyProfile(ctx context.Context) (*model.Profile, error) {
	log := logger.FromCtx(ctx).With(
		zap.String("layer", "resolver"),
		zap.String("method", "MyProfile"),
	)

	userID, ok := utils.GetUserIDFromContext(ctx)
	if !ok {
		log.Warn("unauthorized my profile attempt")
		return nil, fmt.Errorf("unauthorized")
	}

	log = log.With(zap.Uint("user_id", userID))
	log.Info("fetch my profile request received")

	profile, err := r.UserSvc.GetOrCreateProfile(ctx, userID)
	if err != nil {
		log.Error("failed to get or create profile", zap.Error(err))
		return nil, err
	}

	log.Info("profile fetched successfully")

	return mapProfileToGraphQL(profile), nil
}
