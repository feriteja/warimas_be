package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"
	"net/http"
	"time"
	"warimas-be/internal/graph/model"
	"warimas-be/internal/logger"
	"warimas-be/internal/transport"
	"warimas-be/internal/user"
	"warimas-be/internal/utils"

	"go.uber.org/zap"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthResponse, error) {
	log := logger.FromCtx(ctx)

	token, u, err := r.UserSvc.Register(ctx, input.Email, input.Password)
	if err != nil {
		log.Warn("register failed", zap.String("email", input.Email), zap.Error(err))
		return nil, err
	}

	w := transport.GetResponseWriter(ctx) // <-- your helper
	if w != nil {
		http.SetCookie(w, &http.Cookie{
			Name:     "access_token",
			Value:    token,
			Path:     "/",
			HttpOnly: true,
			Secure:   true, // HTTPS only
			SameSite: http.SameSiteNoneMode,
			MaxAge:   60 * 60 * 24, // 24 hours
		})
	}

	log.Info("user registered successfully",
		zap.String("user_id", fmt.Sprint(u.ID)),
		zap.String("email", u.Email),
	)

	return &model.AuthResponse{
		Token: &token,
		User: &model.User{
			ID:    fmt.Sprint(u.ID),
			Email: u.Email,
			Role:  model.Role(u.Role),
		},
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthResponse, error) {
	log := logger.FromCtx(ctx)

	log.Info("Login resolver called",
		zap.String("email", input.Email),
	)

	token, u, err := r.UserSvc.Login(ctx, input.Email, input.Password)
	if err != nil {
		log.Warn("Login failed",
			zap.String("email", input.Email),
			zap.Error(err),
		)
		return nil, err
	}

	w := transport.GetResponseWriter(ctx) // <-- your helper
	if w != nil {
		http.SetCookie(w, &http.Cookie{
			Name:     "access_token",
			Value:    token,
			Path:     "/",
			HttpOnly: true,
			Secure:   true, // HTTPS only
			SameSite: http.SameSiteNoneMode,
			MaxAge:   60 * 60 * 24, // 24 hours
		})
	}

	log.Info("Login successful",
		zap.String("user_id", fmt.Sprint(u.ID)),
		zap.String("email", u.Email),
		zap.String("role", string(u.Role)),
	)

	return &model.AuthResponse{
		Token: &token,
		User: &model.User{
			ID:    fmt.Sprint(u.ID),
			Email: u.Email,
			Role:  model.Role(u.Role),
		},
	}, nil
}

// ForgotPassword is the resolver for the forgotPassword field.
func (r *mutationResolver) ForgotPassword(ctx context.Context, input model.ForgotPasswordInput) (*model.ForgotPasswordResponse, error) {
	log := logger.FromCtx(ctx)

	log.Info("forgot password request received", zap.String("email", input.Email))

	if err := r.UserSvc.ForgotPassword(ctx, input.Email); err != nil {
		log.Error("forgot password failed", zap.Error(err))
		return nil, err
	}

	log.Info("forgot password email sent", zap.String("email", input.Email))

	return &model.ForgotPasswordResponse{
		Success: true,
		Message: utils.StrPtr("If your email is registered, you will receive a password reset link shortly."),
	}, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, input model.ResetPasswordInput) (*model.ResetPasswordResponse, error) {
	log := logger.FromCtx(ctx)

	log.Info("reset password request received")

	if err := r.UserSvc.ResetPassword(ctx, input.Token, input.NewPassword); err != nil {
		log.Error("reset password failed", zap.Error(err))
		return nil, err
	}

	return &model.ResetPasswordResponse{
		Success: true,
		Message: utils.StrPtr("Password successfully reset"),
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	log := logger.FromCtx(ctx)

	w := transport.GetResponseWriter(ctx)
	if w != nil {
		http.SetCookie(w, &http.Cookie{
			Name:     "access_token",
			Value:    "",
			Path:     "/",
			HttpOnly: true,
			Secure:   true,
			SameSite: http.SameSiteNoneMode,
			MaxAge:   -1,
		})
	}

	log.Info("user logged out")

	return true, nil
}

// UpdateProfile is the resolver for the updateProfile field.
// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, input model.UpdateProfileInput) (*model.Profile, error) {
	log := logger.FromCtx(ctx)

	userID, ok := utils.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	var dob *time.Time
	if input.DateOfBirth != nil {
		parsed, err := time.Parse("2006-01-02", *input.DateOfBirth)
		if err != nil {
			log.Error("invalid date format", zap.String("date", *input.DateOfBirth), zap.Error(err))
			return nil, fmt.Errorf("invalid date format, expected YYYY-MM-DD")
		}
		dob = &parsed
	}

	params := user.UpdateProfileParams{
		UserID:      userID,
		FullName:    input.FullName,
		Bio:         input.Bio,
		AvatarURL:   input.AvatarURL,
		Phone:       input.Phone,
		DateOfBirth: dob,
	}

	updated, err := r.UserSvc.UpdateProfile(ctx, params)
	if err != nil {
		return nil, err
	}

	return mapProfileToGraphQL(updated), nil
}

// MyProfile is the resolver for the myProfile field.
func (r *queryResolver) MyProfile(ctx context.Context) (*model.Profile, error) {
	log := logger.FromCtx(ctx)

	userID, ok := utils.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	// Assuming UserSvc has GetOrCreateProfile method
	// You need to implement GetOrCreateProfile in your user service
	profile, err := r.UserSvc.GetOrCreateProfile(ctx, userID)
	if err != nil {
		log.Error("failed to get or create profile", zap.Error(err))
		return nil, err
	}

	return mapProfileToGraphQL(profile), nil
}

func mapProfileToGraphQL(profile *user.Profile) *model.Profile {
	var dob *string
	if profile.DateOfBirth != nil {
		d := profile.DateOfBirth.Format("2006-01-02")
		dob = &d
	}

	return &model.Profile{
		ID:          profile.ID.String(),
		UserID:      fmt.Sprint(profile.UserID),
		FullName:    profile.FullName,
		Bio:         profile.Bio,
		AvatarURL:   profile.AvatarURL,
		Phone:       profile.Phone,
		DateOfBirth: dob,
		CreatedAt:   utils.StrPtr(profile.CreatedAt.Format(time.RFC3339)),
		UpdatedAt:   utils.StrPtr(profile.UpdatedAt.Format(time.RFC3339)),
	}
}
