package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"
	"net/http"
	"warimas-be/internal/graph/model"
	"warimas-be/internal/logger"
	"warimas-be/internal/transport"
	"warimas-be/internal/utils"

	"go.uber.org/zap"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthResponse, error) {
	log := logger.FromCtx(ctx)

	token, u, err := r.UserSvc.Register(ctx, input.Email, input.Password)
	if err != nil {
		log.Warn("register failed", zap.String("email", input.Email), zap.Error(err))
		return nil, err
	}

	w := transport.GetResponseWriter(ctx) // <-- your helper
	if w != nil {
		http.SetCookie(w, &http.Cookie{
			Name:     "access_token",
			Value:    token,
			Path:     "/",
			HttpOnly: true,
			Secure:   true, // HTTPS only
			SameSite: http.SameSiteNoneMode,
			MaxAge:   60 * 60 * 24, // 24 hours
		})
	}

	log.Info("user registered successfully",
		zap.String("user_id", fmt.Sprint(u.ID)),
		zap.String("email", u.Email),
	)

	return &model.AuthResponse{
		Token: &token,
		User: &model.User{
			ID:    fmt.Sprint(u.ID),
			Email: u.Email,
			Role:  model.Role(u.Role),
		},
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthResponse, error) {
	log := logger.FromCtx(ctx)

	log.Info("Login resolver called",
		zap.String("email", input.Email),
	)

	token, u, err := r.UserSvc.Login(ctx, input.Email, input.Password)
	if err != nil {
		log.Warn("Login failed",
			zap.String("email", input.Email),
			zap.Error(err),
		)
		return nil, err
	}

	w := transport.GetResponseWriter(ctx) // <-- your helper
	if w != nil {
		http.SetCookie(w, &http.Cookie{
			Name:     "access_token",
			Value:    token,
			Path:     "/",
			HttpOnly: true,
			Secure:   true, // HTTPS only
			SameSite: http.SameSiteNoneMode,
			MaxAge:   60 * 60 * 24, // 24 hours
		})
	}

	log.Info("Login successful",
		zap.String("user_id", fmt.Sprint(u.ID)),
		zap.String("email", u.Email),
		zap.String("role", string(u.Role)),
	)

	return &model.AuthResponse{
		Token: &token,
		User: &model.User{
			ID:    fmt.Sprint(u.ID),
			Email: u.Email,
			Role:  model.Role(u.Role),
		},
	}, nil
}

// ForgotPassword is the resolver for the forgotPassword field.
func (r *mutationResolver) ForgotPassword(ctx context.Context, input model.ForgotPasswordInput) (*model.ForgotPasswordResponse, error) {
	log := logger.FromCtx(ctx)

	log.Info("forgot password request received", zap.String("email", input.Email))

	if err := r.UserSvc.ForgotPassword(ctx, input.Email); err != nil {
		log.Error("forgot password failed", zap.Error(err))
		return nil, err
	}

	log.Info("forgot password email sent", zap.String("email", input.Email))

	return &model.ForgotPasswordResponse{
		Success: true,
		Message: utils.StrPtr("If your email is registered, you will receive a password reset link shortly."),
	}, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, input model.ResetPasswordInput) (*model.ResetPasswordResponse, error) {
	log := logger.FromCtx(ctx)

	log.Info("reset password request received")

	if err := r.UserSvc.ResetPassword(ctx, input.Token, input.NewPassword); err != nil {
		log.Error("reset password failed", zap.Error(err))
		return nil, err
	}

	return &model.ResetPasswordResponse{
		Success: true,
		Message: utils.StrPtr("Password successfully reset"),
	}, nil
}
